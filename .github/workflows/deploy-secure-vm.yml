name: Deploy VM (Bicep) + Secure + Clean

on:
  push:
    branches: [ main, dev ]
    paths:
      - 'infrastructure-as-a-code-sandbox/bicep/templates/create-virtual-machine/**'
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: vm-deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  deploy-and-clean:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      skip: ${{ steps.pick.outputs.skip }}
      transient: ${{ steps.pick.outputs.transient }}
      param_file: ${{ steps.pick.outputs.param_file }}
      vm_name: ${{ steps.parse.outputs.vm_name }}
      os: ${{ steps.parse_os.outputs.os }}
      os_norm: ${{ steps.os_norm.outputs.os_norm }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Select latest .bicepparam (prefer timestamped)
        id: pick
        shell: bash
        run: |
          set -euo pipefail
          PARAM_DIR="infrastructure-as-a-code-sandbox/bicep/templates/create-virtual-machine"

          write_output () {
            local k="$1"; local v="$2"
            {
              echo "$k<<__EOF__"
              echo "$v"
              echo "__EOF__"
            } >> "$GITHUB_OUTPUT"
          }

          if ! compgen -G "$PARAM_DIR/*.bicepparam" > /dev/null; then
            echo "No .bicepparam files found. Nothing to deploy."
            write_output "skip" "true"
            exit 0
          fi

          TS_PATTERN="$PARAM_DIR"/main*.bicepparam
          latest=""

          if compgen -G "$TS_PATTERN" > /dev/null; then
            echo "Timestamped candidates (newest first):"
            mapfile -t candidates < <(ls -t -- $TS_PATTERN 2>/dev/null | grep -v '/main\.bicepparam$' || true)
            printf '  %s\n' "${candidates[@]:-<none>}"
            if (( ${#candidates[@]} > 0 )); then
              latest="${candidates[0]}"
              echo "Selected timestamped param file: $latest"
              write_output "transient" "true"
            fi
          fi

          if [ -z "$latest" ]; then
            if [ -f "$PARAM_DIR/main.bicepparam" ]; then
              latest="$PARAM_DIR/main.bicepparam"
              echo "Selected baseline param file: $latest"
              write_output "transient" "false"
            else
              echo "Found .bicepparam files, but none matched expected names."
              write_output "skip" "true"
              exit 0
            fi
          fi

          write_output "skip" "false"
          write_output "param_file" "$latest"
          echo "param_file resolved to: [$latest]"

      - name: Parse vmName from param file
        id: parse
        if: steps.pick.outputs.skip == 'false'
        shell: bash
        run: |
          set -euo pipefail
          f="${{ steps.pick.outputs.param_file }}"
          echo "Param file from outputs: [$f]"
          if [ ! -f "$f" ]; then
            echo "::error::Expected a .bicepparam file but got something else."
            p="$(dirname "$f" || true)"; ls -la -- "$p" || true
            exit 1
          fi
          VM_NAME=$(grep -Po "^param\s+vmName\s*=\s*'\K[^']+" -- "$f" || true)
          if [ -z "$VM_NAME" ]; then
            echo "::error::Could not parse vmName from $f"
            exit 1
          fi
          {
            echo "vm_name<<__EOF__"
            echo "$VM_NAME"
            echo "__EOF__"
          } >> "$GITHUB_OUTPUT"
          echo "vmName parsed: $VM_NAME"

      - name: Parse OS from param file
        id: parse_os
        if: steps.pick.outputs.skip == 'false'
        shell: bash
        run: |
          set -euo pipefail
          f="${{ steps.pick.outputs.param_file }}"
          OS_VAL=$(grep -Po "^param\s+OS\s*=\s*'\K[^']+" -- "$f" || true)
          if [ -z "$OS_VAL" ]; then
            echo "::error::Could not parse OS from $f"
            exit 1
          fi
          {
            echo "os<<__EOF__"
            echo "$OS_VAL"
            echo "__EOF__"
          } >> "$GITHUB_OUTPUT"
          echo "OS parsed: $OS_VAL"

      - name: Normalize OS name for secure step
        id: os_norm
        if: steps.pick.outputs.skip == 'false'
        shell: bash
        run: |
          set -euo pipefail
          raw="${{ steps.parse_os.outputs.os }}"
          norm="$raw"
          if [[ "$raw" =~ ^Server(2022|2019|2016)$ ]]; then norm="Windows-Server"; fi
          if [[ "$raw" =~ ^Ubuntu(22|20) ]]; then norm="Ubuntu"; fi
          if [[ "$raw" =~ ^Debian(12|11) ]]; then norm="Debian"; fi
          {
            echo "os_norm<<__EOF__"
            echo "$norm"
            echo "__EOF__"
          } >> "$GITHUB_OUTPUT"
          echo "Normalized OS: $norm"

      - name: Show picked values
        if: steps.pick.outputs.skip == 'false'
        run: |
          echo "PARAM:    ${{ steps.pick.outputs.param_file }}"
          echo "VM_NAME:  ${{ steps.parse.outputs.vm_name }}"
          echo "OS_RAW:   ${{ steps.parse_os.outputs.os }}"
          echo "OS_NORM:  ${{ steps.os_norm.outputs.os_norm }}"

      - name: Assert param file exists
        if: steps.pick.outputs.skip == 'false'
        run: |
          test -f "${{ steps.pick.outputs.param_file }}" || { echo "::error::Param file missing"; exit 1; }

      - name: Deploy Bicep (resource group scope)
        if: steps.pick.outputs.skip == 'false'
        uses: azure/arm-deploy@v1
        with:
          scope: resourcegroup
          subscriptionId:     ${{ secrets.AZURE_SUBSCRIPTION }}
          resourceGroupName:  ${{ secrets.AZURE_RG }}
          template:           ./infrastructure-as-a-code-sandbox/bicep/templates/create-virtual-machine/main.bicep
          parameters:         ${{ steps.pick.outputs.param_file }}
          deploymentName:     vm-deploy-${{ github.run_number }}
          failOnStdErr:       false

      - name: Cleanup timestamped param files
        if: steps.pick.outputs.skip == 'false' && success() && steps.pick.outputs.transient == 'true'
        shell: bash
        run: |
          set -euo pipefail
          PARAM_DIR="infrastructure-as-a-code-sandbox/bicep/templates/create-virtual-machine"
          shopt -s nullglob
          files=( "$PARAM_DIR"/main.*[0-9][0-9][0-9][0-9]*.bicepparam "$PARAM_DIR"/main-*.bicepparam "$PARAM_DIR"/main_*.bicepparam )
          if (( ${#files[@]} > 0 )); then
            git config user.name  "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git rm -f "${files[@]}"
            git commit -m "cleanup: remove transient timestamped .bicepparam after successful deploy [skip ci]"
            git push
          else
            echo "No timestamped .bicepparam files to clean."
          fi

  secure-vm:
    runs-on: ubuntu-latest
    timeout-minutes: 75
    needs: deploy-and-clean
    if: needs.deploy-and-clean.outputs.skip == 'false' && success()
    env:
      VM_NAME: ${{ needs.deploy-and-clean.outputs.vm_name }}
      OS_NAME: ${{ needs.deploy-and-clean.outputs.os_norm }}
      SUBSCRIPTION: ${{ secrets.AZURE_SUBSCRIPTION }}
      RG: ${{ secrets.AZURE_RG }}
      REGION: ${{ secrets.AZURE_REGION }}
      QUARANTINE_NSG_ID: ${{ secrets.QUARANTINE_NSG_ID }}
      # ---- feature flags (default off to avoid charges) ----
      ENABLE_DEFENDER: 'false'
      ENABLE_LA: 'false'
      ENABLE_SENTINEL: 'false'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Ensure Quarantine NSG exists (create if missing)
        shell: bash
        run: |
          set -euo pipefail
          RG_NAME="$RG"
          LOCATION="${REGION:-$(az group show -n "$RG_NAME" --query location -o tsv)}"
          echo "Using location: [$LOCATION] for quarantine NSG"

          if [ -n "${QUARANTINE_NSG_ID:-}" ] && az resource show --ids "$QUARANTINE_NSG_ID" >/dev/null 2>&1; then
            echo "Using provided QUARANTINE_NSG_ID."
            echo "QUARANTINE_NSG_ID=$QUARANTINE_NSG_ID" >> "$GITHUB_ENV"
            exit 0
          fi

          NSG_NAME="quarantine-nsg"
          if ! az network nsg show -g "$RG_NAME" -n "$NSG_NAME" >/dev/null 2>&1; then
            echo "Creating quarantine NSG '$NSG_NAME' in $RG_NAME ($LOCATION)..."
            az network nsg create -g "$RG_NAME" -n "$NSG_NAME" -l "$LOCATION" >/dev/null
            az network nsg rule create -g "$RG_NAME" --nsg-name "$NSG_NAME" \
              -n DenyAllInbound --priority 100 --access Deny --direction Inbound \
              --protocol '*' --source-address-prefixes '*' --source-port-ranges '*' \
              --destination-address-prefixes '*' --destination-port-ranges '*' >/dev/null
            az network nsg rule create -g "$RG_NAME" --nsg-name "$NSG_NAME" \
              -n DenyAllOutbound --priority 101 --access Deny --direction Outbound \
              --protocol '*' --source-address-prefixes '*' --source-port-ranges '*' \
              --destination-address-prefixes '*' --destination-port-ranges '*' >/dev/null
          else
            echo "Quarantine NSG '$NSG_NAME' already exists."
          fi

          NSG_ID=$(az network nsg show -g "$RG_NAME" -n "$NSG_NAME" --query id -o tsv)
          echo "QUARANTINE_NSG_ID=$NSG_ID" >> "$GITHUB_ENV"

      - name: Wait for VM to be running
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..30}; do
            STATE=$(az vm get-instance-view -g "$RG" -n "$VM_NAME" --query "instanceView.statuses[?starts_with(code, 'PowerState/')].code" -o tsv || true)
            echo "Current power state: $STATE"
            if [ "$STATE" = "PowerState/running" ]; then
              echo "VM is running."
              exit 0
            fi
            echo "Waiting 20s for VM to be running..."
            sleep 20
          done
          echo "::error::VM did not reach running state in time."
          exit 1

      # ---------- Windows patching (two passes + verify) ----------
      - name: Windows updates (pass 1 - enable MU + install)
        if: contains(env.OS_NAME, 'Windows-Server')
        shell: bash
        run: |
          PS_SCRIPT='$ErrorActionPreference = [System.Management.Automation.ActionPreference]::Stop; Set-ExecutionPolicy Bypass -Scope Process -Force; [Net.ServicePointManager]::SecurityProtocol=[Net.SecurityProtocolType]::Tls12; Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force; Set-PSRepository -Name ''PSGallery'' -InstallationPolicy Trusted; Install-Module PSWindowsUpdate -Force; Import-Module PSWindowsUpdate; Add-WUServiceManager -MicrosoftUpdate -Confirm:$false | Out-Null; Install-WindowsUpdate -MicrosoftUpdate -AcceptAll -AutoReboot -Verbose'
          az vm run-command invoke \
            --resource-group "$RG" \
            --name "$VM_NAME" \
            --command-id RunPowerShellScript \
            --scripts "$PS_SCRIPT"

      - name: Wait for VM after Windows auto-reboot (pass 1)
        if: contains(env.OS_NAME, 'Windows-Server')
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..30}; do
            STATE=$(az vm get-instance-view -g "$RG" -n "$VM_NAME" --query "instanceView.statuses[?starts_with(code, 'PowerState/')].code" -o tsv || true)
            echo "Current power state: $STATE"
            if [ "$STATE" = "PowerState/running" ]; then
              echo "VM back online."
              exit 0
            fi
            echo "Waiting 20s for Windows to come back..."
            sleep 20
          done
          echo "::warning::VM didn't report running again within the wait window."

      - name: Windows updates (pass 2 - install remaining + reboot if needed)
        if: contains(env.OS_NAME, 'Windows-Server')
        shell: bash
        run: |
          PS_SCRIPT='$ErrorActionPreference = [System.Management.Automation.ActionPreference]::Stop; Import-Module PSWindowsUpdate; Install-WindowsUpdate -MicrosoftUpdate -AcceptAll -AutoReboot -Verbose'
          az vm run-command invoke \
            --resource-group "$RG" \
            --name "$VM_NAME" \
            --command-id RunPowerShellScript \
            --scripts "$PS_SCRIPT"

      - name: Wait for VM after Windows auto-reboot (pass 2)
        if: contains(env.OS_NAME, 'Windows-Server')
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..30}; do
            STATE=$(az vm get-instance-view -g "$RG" -n "$VM_NAME" --query "instanceView.statuses[?starts_with(code, 'PowerState/')].code" -o tsv || true)
            echo "Current power state: $STATE"
            if [ "$STATE" = "PowerState/running" ]; then
              echo "VM back online."
              exit 0
            fi
            echo "Waiting 20s for Windows to come back..."
            sleep 20
          done
          echo "::warning::VM didn't report running again within the wait window."

      - name: Windows updates (final verify)
        if: contains(env.OS_NAME, 'Windows-Server')
        shell: bash
        run: |
          PS_SCRIPT='$ErrorActionPreference = [System.Management.Automation.ActionPreference]::Stop; Import-Module PSWindowsUpdate; $p = Get-WindowsUpdate -MicrosoftUpdate -IgnoreReboot | Where-Object { -not $_.IsInstalled }; if ($p) { Write-Host "Remaining updates:" ($p | Select-Object Title,KB,Size | Out-String) } else { Write-Host "No pending updates detected." }'
          az vm run-command invoke \
            --resource-group "$RG" \
            --name "$VM_NAME" \
            --command-id RunPowerShellScript \
            --scripts "$PS_SCRIPT"

      - name: Windows Update UI reconcile (optional)
        if: contains(env.OS_NAME, 'Windows-Server')
        continue-on-error: true
        shell: bash
        run: |
          PS_SCRIPT='$ErrorActionPreference = [System.Management.Automation.ActionPreference]::Stop;

          # Make sure WU service is up
          try { if ((Get-Service wuauserv).Status -ne ''Running'') { Start-Service wuauserv } } catch {}

          function Invoke-Try { param([string]$Cmd) try { Write-Host "-> $Cmd"; & $Cmd 2>$null | Out-Null; Start-Sleep -Seconds 5; $true } catch { $false } }

          $uso = "$env:SystemRoot\System32\usoclient.exe"
          if (Test-Path $uso) {
            Invoke-Try "$uso RefreshSettings"       | Out-Null
            Invoke-Try "$uso StartScan"             | Out-Null
            Invoke-Try "$uso StartInteractiveScan"  | Out-Null
            Invoke-Try "$uso StartInstall"          | Out-Null
            Invoke-Try "$uso ScanInstallWait"       | Out-Null
          } else {
            Write-Host "usoclient.exe not found; skipping."
          }

          # Fallback: kick scheduled tasks that trigger a scan
          $tasks = @(
            ''\Microsoft\Windows\WindowsUpdate\Scheduled Start'',
            ''\Microsoft\Windows\UpdateOrchestrator\Schedule Scan''
          )
          foreach ($t in $tasks) {
            try { schtasks.exe /Run /TN $t 2>$null | Out-Null; Start-Sleep -Seconds 5 } catch {}
          }

          # Legacy COM detect (works reliably on Server)
          try { (New-Object -ComObject Microsoft.Update.AutoUpdate).DetectNow() | Out-Null } catch {}

          # Nudge legacy reporting (best-effort)
          try { cmd /c wuauclt /detectnow & cmd /c wuauclt /reportnow | Out-Null } catch {}

          # Brief wait loop to let Settings refresh its "Last checked" timestamp
          $deadline = (Get-Date).AddMinutes(3)
          do {
            Start-Sleep -Seconds 5
            try { $last = (New-Object -ComObject Microsoft.Update.AutoUpdate).Results.LastSearchSuccessDate } catch { $last = $null }
          } while ($null -eq $last -and (Get-Date) -lt $deadline)

          Write-Host "Windows Update UI reconcile complete."'
          az vm run-command invoke \
            --resource-group "$RG" \
            --name "$VM_NAME" \
            --command-id RunPowerShellScript \
            --scripts "$PS_SCRIPT"


      # ---------- Linux ----------
      - name: Linux updates (apt)
        if: startsWith(env.OS_NAME, 'Ubuntu') || startsWith(env.OS_NAME, 'Debian')
        shell: bash
        run: |
          az vm run-command invoke \
            --resource-group "$RG" \
            --name "$VM_NAME" \
            --command-id RunShellScript \
            --scripts "sudo apt-get update" "sudo DEBIAN_FRONTEND=noninteractive apt-get -y upgrade"

      # ---------- Defender / LA / Sentinel (all gated) ----------
      - name: Enable Defender for Servers
        if: env.ENABLE_DEFENDER == 'true'
        shell: bash
        run: az security pricing create --name VirtualMachines --tier Standard

      - name: Ensure Log Analytics workspace exists (auto-create)
        if: env.ENABLE_LA == 'true'
        id: la_ws
        shell: bash
        run: |
          set -euo pipefail
          RG_NAME="$RG"
          LOCATION="${REGION:-$(az group show -n "$RG_NAME" --query location -o tsv)}"

          WS_NAME="${{ secrets.AZURE_WORKSPACE || '' }}"
          if [ -z "$WS_NAME" ]; then
            WS_NAME="${RG_NAME}-workspace"
          fi

          echo "Using workspace name: $WS_NAME (location: $LOCATION)"

          if ! az monitor log-analytics workspace show -g "$RG_NAME" -n "$WS_NAME" >/dev/null 2>&1; then
            echo "Creating Log Analytics workspace '$WS_NAME'..."
            az monitor log-analytics workspace create \
              --resource-group "$RG_NAME" \
              --workspace-name "$WS_NAME" \
              --location "$LOCATION" \
              --sku PerGB2018 >/dev/null
          else
            echo "Workspace '$WS_NAME' already exists."
          fi

          WS_ID=$(az monitor log-analytics workspace show -g "$RG_NAME" -n "$WS_NAME" --query id -o tsv)
          {
            echo "WS_NAME<<__EOF__"
            echo "$WS_NAME"
            echo "__EOF__"
            echo "WS_ID<<__EOF__"
            echo "$WS_ID"
            echo "__EOF__"
          } >> "$GITHUB_OUTPUT"

          echo "WORKSPACE_NAME=$WS_NAME" >> "$GITHUB_ENV"
          echo "WORKSPACE_ID=$WS_ID" >> "$GITHUB_ENV"

      - name: Attach Defender default workspace-setting to Log Analytics (optional)
        if: env.ENABLE_LA == 'true'
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          TARGET="$WORKSPACE_ID"
          echo "Linking Defender workspace-setting to: $TARGET"
          if ! az security workspace-setting create --name default --target-workspace "$TARGET" >/dev/null 2>&1; then
            echo "::warning::Failed to attach Defender workspace-setting. Continuing (optional step)."
          else
            echo "Defender workspace-setting configured."
          fi

      - name: Enable Microsoft Sentinel on the workspace (idempotent with retry)
        if: env.ENABLE_SENTINEL == 'true'
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          RG_NAME="$RG"
          WS="$WORKSPACE_NAME"
          LOCATION="${REGION:-$(az group show -n "$RG_NAME" --query location -o tsv)}"

          echo "Target workspace: $WS in $RG_NAME ($LOCATION)"

          az extension add --name sentinel >/dev/null 2>&1 || true

          for i in {1..3}; do
            if az sentinel onboarding-state show -g "$RG_NAME" --workspace-name "$WS" \
               --query properties.onboardingState -o tsv >/dev/null 2>&1; then
              state=$(az sentinel onboarding-state show -g "$RG_NAME" --workspace-name "$WS" \
                        --query properties.onboardingState -o tsv)
              if [ "$state" != "Onboarded" ]; then
                echo "Enabling Sentinel (attempt $i)..."
                az sentinel onboarding-state enable -g "$RG_NAME" --workspace-name "$WS" >/dev/null || true
              else
                echo "Sentinel already Onboarded."
                break
              fi
            else
              echo "Sentinel onboarding-state not available (attempt $i)."
            fi
            sleep 10
          done

          if ! az sentinel onboarding-state show -g "$RG_NAME" --workspace-name "$WS" \
               --query properties.onboardingState -o tsv 2>/dev/null | grep -q Onboarded; then
            echo "Falling back to classic SecurityInsights solution..."
            az extension add --name log-analytics-solution >/dev/null 2>&1 || true
            az monitor log-analytics solution create \
              --resource-group "$RG_NAME" \
              --workspace "$WS" \
              --solution-type SecurityInsights \
              --plan publisher=Microsoft product=OMSGallery/SecurityInsights \
              --location "$LOCATION" >/dev/null || echo "::warning::Classic solution creation failed; continuing."
          fi

      - name: Guardrail — keep Defender for Servers at Free
        if: ${{ env.ENABLE_DEFENDER != 'true' }}
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          TIER=$(az security pricing show --name VirtualMachines --query pricingTier -o tsv || echo Unknown)
          echo "Current Defender Servers tier: ${TIER:-Unknown}"
          if [ "${TIER:-Unknown}" != "Free" ]; then
            echo "Setting Defender for Servers tier to Free..."
            az security pricing create --name VirtualMachines --tier Free
          else
            echo "Already Free. No change."
          fi    

      - name: Tag VM as secured
        shell: bash
        run: |
          az resource tag \
            --ids "/subscriptions/$SUBSCRIPTION/resourceGroups/$RG/providers/Microsoft.Compute/virtualMachines/$VM_NAME" \
            --tags environment=production owner=automation compliance=verified
