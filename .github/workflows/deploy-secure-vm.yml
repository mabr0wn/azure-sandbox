name: Deploy VM (Bicep) + Secure + Clean

on:
  push:
    branches: [ main, dev ]
    paths:
      - 'infrastructure-as-a-code-sandbox/bicep/templates/create-virtual-machine/**'
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: vm-deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  deploy-and-clean:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      skip: ${{ steps.pick.outputs.skip }}
      param_file: ${{ steps.pick.outputs.param_file }}
      vm_name: ${{ steps.parse.outputs.vm_name }}
      os: ${{ steps.parse_os.outputs.os }}
      os_norm: ${{ steps.os_norm.outputs.os_norm }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Prefer latest timestamped .bicepparam, fallback to baseline main.bicepparam
      - name: Select latest .bicepparam (prefer timestamped)
        id: pick
        shell: bash
        run: |
          set -euo pipefail
          PARAM_DIR="infrastructure-as-a-code-sandbox/bicep/templates/create-virtual-machine"

          write_out () { # key, value
            {
              echo "$1<<__EOF__"
              echo "$2"
              echo "__EOF__"
            } >> "$GITHUB_OUTPUT"
          }

          if ! compgen -G "$PARAM_DIR/*.bicepparam" > /dev/null; then
            echo "No .bicepparam files found. Nothing to deploy."
            write_out skip true
            exit 0
          fi

          echo "Candidates (newest first):"
          mapfile -t ALL < <(ls -1t -- "$PARAM_DIR"/*.bicepparam)
          printf ' - %s\n' "${ALL[@]}"

          latest=""
          for f in "${ALL[@]}"; do
            if [ "$(basename "$f")" != "main.bicepparam" ]; then
              latest="$f"
              echo "Selected timestamped param: $latest"
              break
            fi
          done

          if [ -z "${latest}" ]; then
            if [ -f "$PARAM_DIR/main.bicepparam" ]; then
              latest="$PARAM_DIR/main.bicepparam"
              echo "Selected baseline param: $latest"
            else
              echo "No usable .bicepparam files."
              write_out skip true
              exit 0
            fi
          fi

          write_out skip false
          write_out param_file "$latest"
          echo "param_file resolved: $latest"

      - name: Parse vmName from param file
        id: parse
        if: steps.pick.outputs.skip == 'false'
        shell: bash
        run: |
          set -euo pipefail
          f="${{ steps.pick.outputs.param_file }}"
          test -f "$f" || { echo "::error::Param file not found: $f"; exit 1; }
          VM_NAME=$(grep -Po "^param\s+vmName\s*=\s*'\K[^']+" -- "$f" || true)
          if [ -z "$VM_NAME" ]; then
            echo "::error::Could not parse vmName from $f"; exit 1
          fi
          {
            echo "vm_name<<__EOF__"
            echo "$VM_NAME"
            echo "__EOF__"
          } >> "$GITHUB_OUTPUT"
          echo "vmName: $VM_NAME"

      - name: Parse OS from param file
        id: parse_os
        if: steps.pick.outputs.skip == 'false'
        shell: bash
        run: |
          set -euo pipefail
          f="${{ steps.pick.outputs.param_file }}"
          OS_VAL=$(grep -Po "^param\s+OS\s*=\s*'\K[^']+" -- "$f" || true)
          if [ -z "$OS_VAL" ]; then
            echo "::error::Could not parse OS from $f"; exit 1
          fi
          {
            echo "os<<__EOF__"
            echo "$OS_VAL"
            echo "__EOF__"
          } >> "$GITHUB_OUTPUT"
          echo "OS: $OS_VAL"

      - name: Normalize OS name for secure step
        id: os_norm
        if: steps.pick.outputs.skip == 'false'
        shell: bash
        run: |
          set -euo pipefail
          raw="${{ steps.parse_os.outputs.os }}"
          norm="$raw"
          [[ "$raw" =~ ^Server(2022|2019|2016)$ ]] && norm="Windows-Server"
          [[ "$raw" =~ ^Ubuntu(22|20)          ]] && norm="Ubuntu"
          [[ "$raw" =~ ^Debian(12|11)          ]] && norm="Debian"
          {
            echo "os_norm<<__EOF__"
            echo "$norm"
            echo "__EOF__"
          } >> "$GITHUB_OUTPUT"
          echo "OS normalized: $norm"

      - name: Assert param file exists
        if: steps.pick.outputs.skip == 'false'
        run: |
          test -f "${{ steps.pick.outputs.param_file }}" || { echo "::error::Param file missing"; exit 1; }

      - name: Deploy Bicep (resource group scope)
        if: steps.pick.outputs.skip == 'false'
        uses: azure/arm-deploy@v1
        with:
          scope: resourcegroup
          subscriptionId:     ${{ secrets.AZURE_SUBSCRIPTION }}
          resourceGroupName:  ${{ secrets.AZURE_RG }}
          template:           ./infrastructure-as-a-code-sandbox/bicep/templates/create-virtual-machine/main.bicep
          parameters:         ${{ steps.pick.outputs.param_file }}
          deploymentName:     vm-deploy-${{ github.run_number }}
          failOnStdErr:       false

      # Delete the used timestamped param (if the selected file wasn't the baseline)
      - name: Cleanup selected param if timestamped
        if: steps.pick.outputs.skip == 'false' && success()
        shell: bash
        run: |
          set -euo pipefail
          PARAM_DIR="infrastructure-as-a-code-sandbox/bicep/templates/create-virtual-machine"
          f="${{ steps.pick.outputs.param_file }}"
          if [[ "$f" == "$PARAM_DIR/"*".bicepparam" && "$(basename "$f")" != "main.bicepparam" ]]; then
            echo "Removing timestamped param: $f"
            git config user.name  "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git rm -f -- "$f"
            git commit -m "cleanup: remove used timestamped param $f [skip ci]"
            git push
          else
            echo "Selected param is baseline or outside expected path â€” nothing to clean."
          fi

  secure-vm:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: deploy-and-clean
    if: needs.deploy-and-clean.outputs.skip == 'false' && success()
    env:
      VM_NAME:   ${{ needs.deploy-and-clean.outputs.vm_name }}
      OS_NAME:   ${{ needs.deploy-and-clean.outputs.os_norm }}
      SUBSCRIPTION: ${{ secrets.AZURE_SUBSCRIPTION }}
      RG:          ${{ secrets.AZURE_RG }}
      REGION:      ${{ secrets.AZURE_REGION }}
      WORKSPACE:   ${{ secrets.AZURE_WORKSPACE }}
      QUARANTINE_NSG_ID: ${{ secrets.QUARANTINE_NSG_ID }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Ensure Quarantine NSG exists (create if missing)
        shell: bash
        run: |
          set -euo pipefail
          RG_NAME="$RG"
          if [ -n "${REGION:-}" ]; then
            LOCATION="$REGION"
          else
            LOCATION="$(az group show -n "$RG_NAME" --query location -o tsv)"
          fi
          echo "Using location: $LOCATION"

          if [ -n "${QUARANTINE_NSG_ID:-}" ] && az resource show --ids "$QUARANTINE_NSG_ID" >/dev/null 2>&1; then
            echo "Using provided QUARANTINE_NSG_ID"
            echo "QUARANTINE_NSG_ID=$QUARANTINE_NSG_ID" >> "$GITHUB_ENV"
            exit 0
          fi

          NSG_NAME="quarantine-nsg"
          if ! az network nsg show -g "$RG_NAME" -n "$NSG_NAME" >/dev/null 2>&1; then
            echo "Creating NSG '$NSG_NAME'..."
            az network nsg create -g "$RG_NAME" -n "$NSG_NAME" -l "$LOCATION" >/dev/null
            az network nsg rule create -g "$RG_NAME" --nsg-name "$NSG_NAME" \
              -n DenyAllInbound --priority 100 --access Deny --direction Inbound \
              --protocol '*' --source-address-prefixes '*' --source-port-ranges '*' \
              --destination-address-prefixes '*' --destination-port-ranges '*' >/dev/null
            az network nsg rule create -g "$RG_NAME" --nsg-name "$NSG_NAME" \
              -n DenyAllOutbound --priority 101 --access Deny --direction Outbound \
              --protocol '*' --source-address-prefixes '*' --source-port-ranges '*' \
              --destination-address-prefixes '*' --destination-port-ranges '*' >/dev/null
          else
            echo "NSG '$NSG_NAME' already exists."
          fi

          NSG_ID=$(az network nsg show -g "$RG_NAME" -n "$NSG_NAME" --query id -o tsv)
          echo "QUARANTINE_NSG_ID=$NSG_ID" >> "$GITHUB_ENV"
          echo "Resolved NSG ID: $NSG_ID"

      - name: Wait for VM to be running
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..30}; do
            STATE=$(az vm get-instance-view -g "$RG" -n "$VM_NAME" --query "instanceView.statuses[?starts_with(code, 'PowerState/')].code" -o tsv || true)
            echo "Power state: $STATE"
            if [ "$STATE" = "PowerState/running" ]; then
              echo "VM is running."; exit 0
            fi
            sleep 20
          done
          echo "::error::VM did not reach running state in time."; exit 1

      # ---- Windows Updates (installs, then restart & wait) ----
      - name: Windows updates (Security & Critical)
        if: contains(env.OS_NAME, 'Windows-Server')
        shell: bash
        run: |
          set -euo pipefail
          az vm run-command invoke \
            --resource-group "$RG" \
            --name "$VM_NAME" \
            --command-id RunPowerShellScript \
            --scripts '
              Set-ExecutionPolicy Bypass -Scope Process -Force;
              Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force;
              Set-PSRepository -Name PSGallery -InstallationPolicy Trusted;
              Install-Module PSWindowsUpdate -Force;
              Import-Module PSWindowsUpdate;
              # Install from Windows Update + Microsoft Update catalogs
              Install-WindowsUpdate -MicrosoftUpdate -AcceptAll -IgnoreReboot -Verbose
            '

      - name: Restart VM after Windows updates
        if: contains(env.OS_NAME, 'Windows-Server')
        shell: bash
        run: |
          set -euo pipefail
          az vm restart -g "$RG" -n "$VM_NAME"

      - name: Wait for VM after Windows restart
        if: contains(env.OS_NAME, 'Windows-Server')
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..30}; do
            STATE=$(az vm get-instance-view -g "$RG" -n "$VM_NAME" --query "instanceView.statuses[?starts_with(code, 'PowerState/')].code" -o tsv || true)
            echo "Power state: $STATE"
            if [ "$STATE" = "PowerState/running" ]; then
              echo "VM back online."; exit 0
            fi
            sleep 20
          done
          echo "::error::VM did not come back after restart."; exit 1

      # ---- Linux updates ----
      - name: Linux updates (apt)
        if: startsWith(env.OS_NAME, 'Ubuntu') || startsWith(env.OS_NAME, 'Debian')
        run: |
          az vm run-command invoke \
            --resource-group "$RG" \
            --name "$VM_NAME" \
            --command-id RunShellScript \
            --scripts "sudo apt-get update" \
                     "sudo DEBIAN_FRONTEND=noninteractive apt-get -y upgrade"

      # ---- Policy + Quarantine (optional) ----
      - name: Check policy compliance (optional)
        id: policy
        shell: bash
        continue-on-error: true
        run: |
          set -euo pipefail
          RID="/subscriptions/$SUBSCRIPTION/resourceGroups/$RG/providers/Microsoft.Compute/virtualMachines/$VM_NAME"
          non=$(az policy state list --resource "$RID" --query "[?complianceState=='NonCompliant']" -o tsv || true)
          if [ -n "$non" ]; then
            echo "non_compliant=true" >> "$GITHUB_OUTPUT"
          else
            echo "non_compliant=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Quarantine non-compliant VM (optional)
        if: steps.policy.outputs.non_compliant == 'true'
        shell: bash
        run: |
          set -euo pipefail
          NIC_ID=$(az vm show -g "$RG" -n "$VM_NAME" --query 'networkProfile.networkInterfaces[0].id' -o tsv)
          az network nic update --ids "$NIC_ID" --network-security-group "$QUARANTINE_NSG_ID"
          az resource tag --ids "/subscriptions/$SUBSCRIPTION/resourceGroups/$RG/providers/Microsoft.Compute/virtualMachines/$VM_NAME" \
            --tags quarantine=true reason=non_compliance

      # ---- Defender + Sentinel ----
      - name: Enable Defender for Servers
        if: steps.policy.outputs.non_compliant != 'true'
        run: az security pricing create --name VirtualMachines --tier Standard

      - name: Attach to Sentinel (Log Analytics) (name must be 'default')
        if: steps.policy.outputs.non_compliant != 'true'
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          TARGET="/subscriptions/$SUBSCRIPTION/resourceGroups/$RG/providers/Microsoft.OperationalInsights/workspaces/$WORKSPACE"
          EXISTING=$(az security workspace-setting list --query "[?name=='default'].name | [0]" -o tsv || true)
          if [ "$EXISTING" = "default" ]; then
            echo "Updating 'default' workspace-setting -> $TARGET"
            az security workspace-setting update --name default --target-workspace "$TARGET"
          else
            echo "Creating 'default' workspace-setting -> $TARGET"
            az security workspace-setting create --name default --target-workspace "$TARGET"
          fi

      - name: Ensure Microsoft Sentinel solution enabled (optional)
        if: steps.policy.outputs.non_compliant != 'true'
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          az monitor log-analytics solution create \
            --resource-group "$RG" \
            --workspace-name "$WORKSPACE" \
            --solution-type SecurityInsights

      - name: Tag VM as secured
        if: steps.policy.outputs.non_compliant != 'true'
        run: |
          az resource tag \
            --ids "/subscriptions/$SUBSCRIPTION/resourceGroups/$RG/providers/Microsoft.Compute/virtualMachines/$VM_NAME" \
            --tags environment=production owner=automation compliance=verified
