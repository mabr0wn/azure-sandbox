name: Deploy VM (Bicep) + Secure + Clean

on:
  push:
    branches: [ main, dev ]
    paths:
      - 'infrastructure-as-a-code-sandbox/bicep/templates/create-virtual-machine/**'
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: vm-deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  deploy-and-clean:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      skip: ${{ steps.pick.outputs.skip }}
      transient: ${{ steps.pick.outputs.transient }}
      param_file: ${{ steps.pick.outputs.param_file }}
      vm_name: ${{ steps.parse.outputs.vm_name }}
      os: ${{ steps.parse_os.outputs.os }}
      os_norm: ${{ steps.os_norm.outputs.os_norm }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Select latest .bicepparam (prefer timestamped)
        id: pick
        shell: bash
        run: |
          set -euo pipefail
          PARAM_DIR="infrastructure-as-a-code-sandbox/bicep/templates/create-virtual-machine"

          write_output () {
            local k="$1"; local v="${2:-}"
            {
              echo "$k<<__EOF__"
              echo "$v"
              echo "__EOF__"
            } >> "$GITHUB_OUTPUT"
          }

          if ! compgen -G "$PARAM_DIR/*.bicepparam" >/dev/null; then
            echo "No .bicepparam files found. Nothing to deploy."
            write_output skip true
            exit 0
          fi

          # Prefer timestamped param like: main.*.bicepparam (NOT main.bicepparam)
          latest=""
          mapfile -t ts_list < <(ls -t -- "$PARAM_DIR"/main.*.bicepparam 2>/dev/null | grep -vE '/main\.bicepparam$' || true)
          if (( ${#ts_list[@]} > 0 )); then
            latest="${ts_list[0]}"
            echo "Selected timestamped param: $latest"
            write_output transient true
          fi

          # Fallback to baseline
          if [ -z "$latest" ] && [ -f "$PARAM_DIR/main.bicepparam" ]; then
            latest="$PARAM_DIR/main.bicepparam"
            echo "Selected baseline param: $latest"
            write_output transient false
          fi

          if [ -z "$latest" ]; then
            echo "Found .bicepparam files, but none matched expected names."
            write_output skip true
            exit 0
          fi

          write_output skip false
          write_output param_file "$latest"
          echo "param_file resolved to: [$latest]"

      - name: Parse vmName from param file
        id: parse
        if: steps.pick.outputs.skip == 'false'
        shell: bash
        run: |
          set -euo pipefail
          f="${{ steps.pick.outputs.param_file }}"
          if [ ! -f "$f" ]; then
            echo "::error::Expected a .bicepparam file path, got: $f"
            exit 1
          fi
          VM_NAME=$(grep -Po "^param\s+vmName\s*=\s*'\K[^']+" -- "$f" || true)
          if [ -z "$VM_NAME" ]; then
            echo "::error::Could not parse vmName from $f"
            exit 1
          fi
          {
            echo "vm_name<<__EOF__"
            echo "$VM_NAME"
            echo "__EOF__"
          } >> "$GITHUB_OUTPUT"
          echo "vmName parsed: $VM_NAME"

      - name: Parse OS from param file
        id: parse_os
        if: steps.pick.outputs.skip == 'false'
        shell: bash
        run: |
          set -euo pipefail
          f="${{ steps.pick.outputs.param_file }}"
          OS_VAL=$(grep -Po "^param\s+OS\s*=\s*'\K[^']+" -- "$f" || true)
          if [ -z "$OS_VAL" ]; then
            echo "::error::Could not parse OS from $f"
            exit 1
          fi
          {
            echo "os<<__EOF__"
            echo "$OS_VAL"
            echo "__EOF__"
          } >> "$GITHUB_OUTPUT"
          echo "OS parsed: $OS_VAL"

      - name: Normalize OS name for secure step
        id: os_norm
        if: steps.pick.outputs.skip == 'false'
        shell: bash
        run: |
          set -euo pipefail
          raw="${{ steps.parse_os.outputs.os }}"
          norm="$raw"
          [[ "$raw" =~ ^Server(2022|2019|2016)$ ]] && norm="Windows-Server"
          [[ "$raw" =~ ^Ubuntu(22|20) ]] && norm="Ubuntu"
          [[ "$raw" =~ ^Debian(12|11) ]] && norm="Debian"
          {
            echo "os_norm<<__EOF__"
            echo "$norm"
            echo "__EOF__"
          } >> "$GITHUB_OUTPUT"
          echo "Normalized OS: $norm"

      - name: Show picked values
        if: steps.pick.outputs.skip == 'false'
        run: |
          echo "PARAM:    ${{ steps.pick.outputs.param_file }}"
          echo "VM_NAME:  ${{ steps.parse.outputs.vm_name }}"
          echo "OS_RAW:   ${{ steps.parse_os.outputs.os }}"
          echo "OS_NORM:  ${{ steps.os_norm.outputs.os_norm }}"

      - name: Assert param file exists
        if: steps.pick.outputs.skip == 'false'
        run: |
          test -f "${{ steps.pick.outputs.param_file }}"

      - name: Deploy Bicep (resource group scope)
        if: steps.pick.outputs.skip == 'false'
        uses: azure/arm-deploy@v1
        with:
          scope: resourcegroup
          subscriptionId:     ${{ secrets.AZURE_SUBSCRIPTION }}
          resourceGroupName:  ${{ secrets.AZURE_RG }}
          template:           ./infrastructure-as-a-code-sandbox/bicep/templates/create-virtual-machine/main.bicep
          parameters:         ${{ steps.pick.outputs.param_file }}
          deploymentName:     vm-deploy-${{ github.run_number }}
          failOnStdErr:       false

      - name: Cleanup timestamped param files
        if: steps.pick.outputs.skip == 'false' && success() && steps.pick.outputs.transient == 'true'
        shell: bash
        run: |
          set -euo pipefail
          PARAM_DIR="infrastructure-as-a-code-sandbox/bicep/templates/create-virtual-machine"
          shopt -s nullglob
          files=( "$PARAM_DIR"/main.*[0-9]*.bicepparam )
          if (( ${#files[@]} > 0 )); then
            git config user.name  "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git rm -f "${files[@]}"
            git commit -m "cleanup: remove transient timestamped .bicepparam after successful deploy [skip ci]"
            git push
          else
            echo "No timestamped .bicepparam files to clean."
          fi

  secure-vm:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: deploy-and-clean
    if: needs.deploy-and-clean.outputs.skip == 'false' && success()
    env:
      VM_NAME: ${{ needs.deploy-and-clean.outputs.vm_name }}
      OS_NAME: ${{ needs.deploy-and-clean.outputs.os_norm }}
      SUBSCRIPTION: ${{ secrets.AZURE_SUBSCRIPTION }}
      RG: ${{ secrets.AZURE_RG }}
      REGION: ${{ secrets.AZURE_REGION }}
      WORKSPACE: ${{ secrets.AZURE_WORKSPACE }}
      QUARANTINE_NSG_ID: ${{ secrets.QUARANTINE_NSG_ID }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Ensure Quarantine NSG exists (create if missing)
        shell: bash
        run: |
          set -euo pipefail
          RG_NAME="$RG"
          LOCATION="${REGION:-$(az group show -n "$RG_NAME" --query location -o tsv)}"
          echo "Using location: [$LOCATION] for quarantine NSG"

          if [ -n "${QUARANTINE_NSG_ID:-}" ] && az resource show --ids "$QUARANTINE_NSG_ID" >/dev/null 2>&1; then
            echo "Using provided QUARANTINE_NSG_ID."
            echo "QUARANTINE_NSG_ID=$QUARANTINE_NSG_ID" >> "$GITHUB_ENV"
            exit 0
          fi

          NSG_NAME="quarantine-nsg"
          if ! az network nsg show -g "$RG_NAME" -n "$NSG_NAME" >/dev/null 2>&1; then
            echo "Creating quarantine NSG '$NSG_NAME'..."
            az network nsg create -g "$RG_NAME" -n "$NSG_NAME" -l "$LOCATION" >/dev/null
            az network nsg rule create -g "$RG_NAME" --nsg-name "$NSG_NAME" \
              -n DenyAllInbound --priority 100 --access Deny --direction Inbound \
              --protocol '*' --source-address-prefixes '*' --source-port-ranges '*' \
              --destination-address-prefixes '*' --destination-port-ranges '*' >/dev/null
            az network nsg rule create -g "$RG_NAME" --nsg-name "$NSG_NAME" \
              -n DenyAllOutbound --priority 101 --access Deny --direction Outbound \
              --protocol '*' --source-address-prefixes '*' --source-port-ranges '*' \
              --destination-address-prefixes '*' --destination-port-ranges '*' >/dev/null
          else
            echo "Quarantine NSG '$NSG_NAME' already exists."
          fi

          NSG_ID=$(az network nsg show -g "$RG_NAME" -n "$NSG_NAME" --query id -o tsv)
          echo "QUARANTINE_NSG_ID=$NSG_ID" >> "$GITHUB_ENV"
          echo "Resolved QUARANTINE_NSG_ID: $NSG_ID"

      - name: Wait for VM to be running
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..30}; do
            STATE=$(az vm get-instance-view -g "$RG" -n "$VM_NAME" --query "instanceView.statuses[?starts_with(code, 'PowerState/')].code" -o tsv || true)
            echo "Current power state: $STATE"
            if [ "$STATE" = "PowerState/running" ]; then
              echo "VM is running."
              exit 0
            fi
            echo "Waiting 20s..."
            sleep 20
          done
          echo "::error::VM did not reach running state in time."
          exit 1

      # ---------- WINDOWS UPDATES: Two-pass with reboot ----------
      - name: Windows updates (install + reboot if needed)
        if: contains(env.OS_NAME, 'Windows-Server')
        run: |
          az vm run-command invoke \
            --resource-group "$RG" \
            --name "$VM_NAME" \
            --command-id RunPowerShellScript \
            --scripts @- <<'PS1'
          $ErrorActionPreference = 'Stop'
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force

          Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force
          try { Set-PSRepository -Name 'PSGallery' -InstallationPolicy Trusted } catch {}
          if (-not (Get-Module -ListAvailable -Name PSWindowsUpdate)) { Install-Module PSWindowsUpdate -Force }
          Import-Module PSWindowsUpdate
          Add-WUServiceManager -MicrosoftUpdate -ErrorAction SilentlyContinue | Out-Null

          Write-Host "== First pass: installing available updates =="
          Get-WindowsUpdate -MicrosoftUpdate -AcceptAll -Install -IgnoreReboot -Verbose | Out-String | Write-Host

          $reboot = (Get-WURebootStatus).RebootRequired
          Write-Host "RebootRequired=$reboot"
          if ($reboot) {
            Write-Host "Restarting due to updates..."
            Restart-Computer -Force
          }
          PS1

      - name: Wait for VM after Windows auto-reboot
        if: contains(env.OS_NAME, 'Windows-Server')
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..30}; do
            STATE=$(az vm get-instance-view -g "$RG" -n "$VM_NAME" --query "instanceView.statuses[?starts_with(code, 'PowerState/')].code" -o tsv || true)
            echo "Current power state: $STATE"
            if [ "$STATE" = "PowerState/running" ]; then
              echo "VM back online."
              exit 0
            fi
            echo "Waiting 20s..."
            sleep 20
          done
          echo "::error::VM did not reach running state in time."
          exit 1

      - name: Windows updates (second pass + verify)
        if: contains(env.OS_NAME, 'Windows-Server')
        run: |
          az vm run-command invoke \
            --resource-group "$RG" \
            --name "$VM_NAME" \
            --command-id RunPowerShellScript \
            --scripts @- <<'PS1'
          $ErrorActionPreference = 'Stop'
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          Import-Module PSWindowsUpdate
          Add-WUServiceManager -MicrosoftUpdate -ErrorAction SilentlyContinue | Out-Null

          Write-Host "== Second pass =="
          Get-WindowsUpdate -MicrosoftUpdate -AcceptAll -Install -IgnoreReboot -Verbose | Out-String | Write-Host

          $pending = (Get-WindowsUpdate -MicrosoftUpdate -ListOnly -IgnoreReboot | Measure-Object).Count
          $reboot  = (Get-WURebootStatus).RebootRequired
          Write-Host "PendingCount=$pending"
          Write-Host "RebootRequired=$reboot"
          if ($reboot) {
            Write-Host "Final restart due to updates..."
            Restart-Computer -Force
          }
          PS1

      # ---------- LINUX UPDATES ----------
      - name: Linux updates (apt)
        if: startsWith(env.OS_NAME, 'Ubuntu') || startsWith(env.OS_NAME, 'Debian')
        run: |
          az vm run-command invoke \
            --resource-group "$RG" \
            --name "$VM_NAME" \
            --command-id RunShellScript \
            --scripts "sudo apt-get update" \
                     "sudo DEBIAN_FRONTEND=noninteractive apt-get -y upgrade"

      # ---------- Defender pricing ----------
      - name: Enable Defender for Servers
        run: az security pricing create --name VirtualMachines --tier Standard

      # ---------- Attach Security Center to Log Analytics (optional, robust) ----------
      - name: Attach to Sentinel (Log Analytics) (name must be 'default')
        shell: bash
        continue-on-error: true
        run: |
          set -euo pipefail
          if [ -z "${WORKSPACE:-}" ]; then
            echo "No AZURE_WORKSPACE provided; skipping workspace-setting."
            exit 0
          fi
          # Validate workspace existence and get its ID
          WS_ID=$(az monitor log-analytics workspace show -g "$RG" -n "$WORKSPACE" --query id -o tsv 2>/dev/null || true)
          if [ -z "$WS_ID" ]; then
            echo "::warning::Workspace '$WORKSPACE' not found in RG '$RG'. Skipping workspace-setting."
            exit 0
          fi
          echo "Creating 'default' workspace-setting -> $WS_ID"
          az security workspace-setting create --name default --target-workspace "$WS_ID"

      # ---------- (Optional) Ensure Sentinel solution is enabled (best-effort) ----------
      - name: Ensure Microsoft Sentinel solution enabled (optional)
        shell: bash
        continue-on-error: true
        run: |
          set -euo pipefail
          if [ -z "${WORKSPACE:-}" ]; then
            echo "No AZURE_WORKSPACE provided; skipping Sentinel solution."
            exit 0
          fi
          WS_ID=$(az monitor log-analytics workspace show -g "$RG" -n "$WORKSPACE" --query id -o tsv 2>/dev/null || true)
          if [ -z "$WS_ID" ]; then
            echo "Workspace not found; skipping Sentinel solution."
            exit 0
          fi
          # Install extension if needed
          az config set extension.use_dynamic_install=yes_without_prompt >/dev/null 2>&1 || true
          # Enable Sentinel solution (SecurityInsights). Name format typically SecurityInsights(<workspaceName>)
          LOC="${REGION:-$(az group show -n "$RG" --query location -o tsv)}"
          az monitor log-analytics solution create \
            --resource-group "$RG" \
            --location "$LOC" \
            --solution-type SecurityInsights \
            --workspace "$WS_ID" \
            --tags provisioned-by=github-actions || true

      - name: Tag VM as secured
        run: |
          az resource tag \
            --ids "/subscriptions/$SUBSCRIPTION/resourceGroups/$RG/providers/Microsoft.Compute/virtualMachines/$VM_NAME" \
            --tags environment=production owner=automation compliance=verified
